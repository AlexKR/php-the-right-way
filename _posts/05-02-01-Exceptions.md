---
title: Винятки
isChild: true
---

## Винятки

Винятки являються стандартною частиною найбільш популярних мов програмування, та вони є часто обділені увагою розробниками PHP. Мови, такі як Ruby, надзвичайно детально обробляють Винятки, тому коли щось йде не так, наприклад HTTP запит не вдається, або запит до бази даних відбувається неправильно, або навіть якщо зображення не може знайтися, Ruby (або gems, котрі використовуються) видадуть виняток на екран, що зразу дозволить зрозуміти, де помилка.

PHP сам по собі, досить слабкий в цьому і виклик `file_get_contents()` зазвичай видасть вам тільки `FALSE` та попередження. Багато старіших PHP фреймворків, як CodeIgniter, просто повернуть false, добавлять повідомлення у їх власний журнал та можливо дадуть вам можливість використовувати метод `$this->upload->get_error()`, щоб глянути, що пішло не так. Проблема в тому, що ви повинні шукати помилку і перевіряти документацію, щоб зрозуміти, який помилковий метод може бути в цьому класі, замість того, щоб зробити все це очевидним.

Ще одна проблема, коли класи автоматично видають помилку на екран і закривають процес. Коли ви робите подібне, ви не даєте можливості другому розробнику динамічно обробити цю помилку. Винятки повинні бути викинуті, щоб дати розробнику знати про помилку, щоб він міг вибрати як її вирішити. Наприклад:

{% highlight php %}
<?php
$email = new Fuel\Email;
$email->subject('My Subject');
$email->body('How the heck are you?');
$email->to('guy@example.com', 'Some Guy');

try
{
    $email->send();
}
catch(Fuel\Email\ValidationFailedException $e)
{
    // Валідація не вдалася
}
catch(Fuel\Email\SendingFailedException $e)
{
    // Драйвер не може відправити повідомлення
}
{% endhighlight %}

### SPL Винятки

Виняток за замовчуванням не має значення і найбільш поширено надавати значення встановлюючи його назву:

{% highlight php %}
<?php
class ValidationException extends Exception {}
{% endhighlight %}

Це означає, що ви можете добавити кілька блоків відлову і обробки різних винятків по різному. Це може призвести до створення <em>багатьох</em> визначених винятків, деякі з котрих можна було б уникнути, використовуючи винятки SPL, що надаються [розшиненням SPL][splext]. 

Якщо наприклад ви використовуєте магічний метод `__call()` та був запит на невірний метод, тоді замість видачі стандартного невизначеного винятку, чи створення окремого винятку для цього ви можете просто `throw new BadFunctionCallException;`

* [Читати про винятки Exceptions][exceptions]
* [Читати про SPL Exceptions][splexe]
* [Вкладені винятки в PHP][nesting-exceptions-in-php]
* [Кращі практики винятків в PHP 5.3][exception-best-practices53]

[exceptions]: http://php.net/manual/en/language.exceptions.php
[splexe]: http://php.net/manual/en/spl.exceptions.php
[splext]: /#standard_php_library
[exception-best-practices53]: http://ralphschindler.com/2010/09/15/exception-best-practices-in-php-5-3
[nesting-exceptions-in-php]: http://www.brandonsavage.net/exceptional-php-nesting-exceptions-in-php/
